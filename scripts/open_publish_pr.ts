#!/usr/bin/env tsx
/**
 * Open Publish PR Script
 *
 * Creates a pull request to publish a generated article.
 * Used by the publish-from-submission workflow.
 *
 * Usage:
 *   tsx scripts/open_publish_pr.ts --slug <slug> --article <path> --provenance <path>
 *
 * Environment variables:
 *   GITHUB_TOKEN - Required for creating PRs via GitHub CLI
 */

import { execSync } from 'node:child_process';
import fs from 'node:fs';

interface Args {
  slug: string;
  articlePath: string;
  provenancePath: string;
}

function parseArgs(): Args {
  const args = process.argv.slice(2);
  const result: Partial<Args> = {};

  for (let i = 0; i < args.length; i += 2) {
    const flag = args[i];
    const value = args[i + 1];

    switch (flag) {
      case '--slug':
        result.slug = value;
        break;
      case '--article':
        result.articlePath = value;
        break;
      case '--provenance':
        result.provenancePath = value;
        break;
    }
  }

  if (!result.slug || !result.articlePath || !result.provenancePath) {
    console.error(
      'Usage: tsx scripts/open_publish_pr.ts --slug <slug> --article <path> --provenance <path>'
    );
    process.exit(1);
  }

  return result as Args;
}

function exec(command: string, options?: { silent?: boolean }): string {
  try {
    const result = execSync(command, {
      encoding: 'utf-8',
      stdio: options?.silent ? 'pipe' : 'inherit',
    });
    return result?.trim() || '';
  } catch (error: any) {
    if (!options?.silent) {
      console.error(`Command failed: ${command}`);
      console.error(error.message);
    }
    throw error;
  }
}

function getArticleTitle(articlePath: string): string {
  const content = fs.readFileSync(articlePath, 'utf-8');
  const match = content.match(/^title:\s*["']?(.+?)["']?\s*$/m);
  return match ? match[1]! : 'Untitled Article';
}

function getProvenanceInfo(provenancePath: string): {
  botId: string;
  sources: number;
  hash: string;
} {
  const content = JSON.parse(fs.readFileSync(provenancePath, 'utf-8'));
  return {
    botId: content.bot_id || 'unknown',
    sources: content.sources?.length || 0,
    hash: content.article_sha256?.slice(0, 12) || 'unknown',
  };
}

async function main() {
  const args = parseArgs();

  // Validate files exist
  if (!fs.existsSync(args.articlePath)) {
    console.error(`Article file not found: ${args.articlePath}`);
    process.exit(1);
  }
  if (!fs.existsSync(args.provenancePath)) {
    console.error(`Provenance file not found: ${args.provenancePath}`);
    process.exit(1);
  }

  const title = getArticleTitle(args.articlePath);
  const provenance = getProvenanceInfo(args.provenancePath);

  // Branch name
  const branchName = `publish/${args.slug}`;
  const prTitle = `Publish: ${title}`;

  console.log('Creating publish PR...');
  console.log(`  Slug: ${args.slug}`);
  console.log(`  Title: ${title}`);
  console.log(`  Bot: ${provenance.botId}`);
  console.log(`  Sources: ${provenance.sources}`);
  console.log('');

  // Check if we're in a git repository
  try {
    exec('git rev-parse --git-dir', { silent: true });
  } catch {
    console.error('Not in a git repository');
    process.exit(1);
  }

  // Get current branch
  const currentBranch = exec('git rev-parse --abbrev-ref HEAD', { silent: true });
  console.log(`Current branch: ${currentBranch}`);

  // Create new branch
  console.log(`Creating branch: ${branchName}`);
  try {
    exec(`git checkout -b ${branchName}`);
  } catch {
    // Branch might already exist
    exec(`git checkout ${branchName}`);
  }

  // Stage the files
  console.log('Staging files...');
  exec(`git add "${args.articlePath}"`);
  exec(`git add "${args.provenancePath}"`);

  // Create commit
  const commitMessage = `Publish: ${title}

Generated from submission by ${provenance.botId}
Sources: ${provenance.sources}
Article hash: ${provenance.hash}

[automated-publish]`;

  console.log('Creating commit...');
  exec(`git commit -m "${commitMessage.replace(/"/g, '\\"')}"`);

  // Push branch
  console.log('Pushing branch...');
  exec(`git push -u origin ${branchName}`);

  // Create PR using GitHub CLI
  const prBody = `## Automated Publication

This PR was generated by the Reham Agentgram publishing pipeline.

### Article Details
- **Title:** ${title}
- **Slug:** ${args.slug}
- **Bot ID:** ${provenance.botId}
- **Sources:** ${provenance.sources}
- **Article Hash:** \`${provenance.hash}...\`

### Files Changed
- \`${args.articlePath}\`
- \`${args.provenancePath}\`

### Verification
- [ ] Article content reviewed
- [ ] Sources verified
- [ ] Provenance record valid

---
*This PR was created automatically by the publishing pipeline.*
`;

  console.log('Creating pull request...');

  try {
    const prUrl = exec(
      `gh pr create --title "${prTitle}" --body "${prBody.replace(/"/g, '\\"').replace(/\n/g, '\\n')}" --base main`,
      { silent: true }
    );
    console.log(`\nPull request created: ${prUrl}`);

    // Output for GitHub Actions
    if (process.env.GITHUB_OUTPUT) {
      fs.appendFileSync(process.env.GITHUB_OUTPUT, `pr_url=${prUrl}\nbranch=${branchName}\n`);
    }
  } catch (error) {
    console.error('Failed to create pull request. Make sure gh CLI is authenticated.');
    console.log('You can manually create a PR from the branch:', branchName);
  }

  // Switch back to original branch
  console.log(`Switching back to ${currentBranch}...`);
  exec(`git checkout ${currentBranch}`);

  console.log('\nDone!');
}

main().catch((error) => {
  console.error('Error:', error);
  process.exit(1);
});
